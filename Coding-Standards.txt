## CODING STANDARDS

### KEY RULES

* **TABS**
  Use K\&R style (brace on same line)
  Indentation must use tabs (tab = 4 spaces)

* **NAMING CONVENTIONS**

  * Variables: camelCase
  * Functions: PascalCase
  * Constants: UPPER\_CASE

## GENERAL BEST PRACTICES

* **PROCEDURES**
  Prefer pure functions and explicit logic.
  Avoid hidden behavior, method chaining, and implicit side effects.

  * ✓ `Length(thisVector - thatVector);`
  * ✗ `thisVector.DistanceTo(thatVector);`

  When the engine provides a simple built-in, don't rewrite it just for style.

  * ✓ `vectorA.Normalized().Dot(vectorB);`
  * ✗ `CustomNormalize(vector); CustomDotProduct(normalizedA, normalizedB);`

* **DATA**
  Keep logic out of data structures. Use plain structs.

  * ✓ `struct Enemy { int hp; int type; };`
  * ✓ `if (IsDead(enemy)) HandleDeath(enemy);`
  * ✗ `enemy.HandleDamage(damageAmount);`
    *Reason: Logic should be visible and separate from mutable state.*

* **READABILITY**
  Prioritize clarity over brevity. Avoid abbreviations.

  * ✓ `CalculateProjectileVelocity()`
  * ✗ `cPV()`
  * ✗ `calcProjVel()`
  * ✗ `calculateProjVel()`

* **COMMENTS**
  Use comments rarely. Only comment on *why* code exists, not *how* it works. Well-written code should be self-evident.

* **FUNCTION LENGTH**
  Long functions are acceptable.
  Extract logic only when:

  * It helps with reuse

  * You want an early return or clearer flow
    Don’t over-abstract two-liners unless used in multiple places.

  * ✓ `FormatDisplayName(); ParseConfigFile();` — reused helpers

  * ✗ `ExhaustiveSearchDirectSearchMultilaterationService();` if used once

* **INHERITANCE**
  Avoid inheritance/polymorphism unless strictly required by the engine.
  Prefer composition and flat data-driven logic.
  Virtual methods make control flow less obvious.
